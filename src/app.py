# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ouwHrN5ZjmXJge8YI1EDX9fAh6D00mem

The visualizations I mentioned can be beneficial to researchers, policymakers, educators, and community organizations. Here's how each group could make use of the visualizations:

Researchers: Researchers studying educational attainment trends can analyze the visualizations to identify patterns, trends, and disparities in qualification levels across local authorities. The visualizations can provide insights into the effectiveness of educational policies and interventions over time.

Policymakers: Policymakers can use the visualizations to understand the changes in educational attainment and make informed decisions regarding resource allocation, targeting specific areas that require additional support, and evaluating the impact of policies on educational outcomes.

Educators: Educators can utilize the visualizations to gain a deeper understanding of the educational landscape in different local authorities. They can identify areas with higher or lower qualification levels, which can help inform curriculum development, resource allocation, and targeted interventions to address specific educational needs.

Community Organizations: Nonprofit organizations, community groups, and local authorities themselves can benefit from the visualizations by identifying areas with low educational attainment. They can then use this information to design and implement initiatives aimed at improving educational opportunities, promoting lifelong learning, and reducing educational disparities within their communities.
"""

import numpy as np
import panel as pn
import pandas as pd
import json,os
import plotly.graph_objects as go
import plotly.express as px
from dash import dash, dcc, html, ctx, Input, Output, callback
import hvplot.pandas

# cwd = os.getcwd()
# csv_file_path = os.path.join(cwd, 'data', '2021_HQUAL_LOWER_TIER.csv')
data = pd.read_csv('https://raw.githubusercontent.com/nenlep/python-app/main/data/2021_HQUAL_LOWER_TIER.csv')

# data = pd.read_csv('./data/2021_HQUAL_LOWER_TIER.csv')
data

# Identify columns with "Unnamed:" in their names
unnamed_cols = [col for col in data.columns if 'Unnamed:' in col]

# Drop the identified columns
data = data.drop(columns=unnamed_cols)

data.rename(columns= {'Highest level of qualification (8 categories) Code':'highest_qualification_level', 'Highest level of qualification (8 categories)':'highest_qualification', 'Lower tier local authorities':'local_authority', 'Lower tier local authorities Code':'local_authorities_code'},inplace=True)
data

data.loc[data['local_authority']== 'Hartlepool']

data = data.drop(data[data['highest_qualification_level'] == -8].index)
data

data.highest_qualification.unique()

import re
patterns = {
    r'Level 1 and entry level qualifications: 1 to 4 GCSEs grade A\* to C, Any GCSEs at other grades, O levels or CSEs \(any grades\), 1 AS level, NVQ level 1, Foundation GNVQ, Basic or Essential Skills':
        'Level 1 qualifications',
    r'Level 2 qualifications: 5 or more GCSEs \(A\* to C or 9 to 4\), O levels \(passes\), CSEs \(grade 1\), School Certification, 1 A level, 2 to 3 AS levels, VCEs, Intermediate or Higher Diploma, Welsh Baccalaureate Intermediate Diploma, NVQ level 2, Intermediate GNVQ, City and Guilds Craft, BTEC First or General Diploma, RSA Diploma':
        'Level 2 qualifications',
    r'Level 3 qualifications: 2 or more A levels or VCEs, 4 or more AS levels, Higher School Certificate, Progression or Advanced Diploma, Welsh Baccalaureate Advance Diploma, NVQ level 3; Advanced GNVQ, City and Guilds Advanced Craft, ONC, OND, BTEC National, RSA Advanced Diploma':
        'Level 3 qualifications',
    r'Level 4 qualifications or above: degree \(BA, BSc\), higher degree \(MA, PhD, PGCE\), NVQ level 4 to 5, HNC, HND, RSA Higher Diploma, BTEC Higher level, professional qualifications \(for example, teaching, nursing, accountancy\)':
        'Level 4 qualifications and above',
    r'Other: vocational or work-related qualifications, other qualifications achieved in England or Wales, qualifications achieved outside England or Wales \(equivalent not stated or unknown\)':
        'Other qualifications'
}

# Replace the patterns in the 'highest_qualification' column using regular expressions
for pattern, replacement in patterns.items():
    data['highest_qualification'] = data['highest_qualification'].apply(lambda x: re.sub(pattern, replacement, str(x)))

data

data.local_authority.nunique()

data['Observation'].astype(str).astype(int)

data['Observation'].dtype

data.highest_qualification

# cwd = os.getcwd()
# csv_file_path = os.path.join(cwd, 'data', '2011_HQUAL_LOWER_TIER.csv')
df = pd.read_csv('https://raw.githubusercontent.com/nenlep/python-app/main/data/2011_HQUAL_LOWER_TIER.csv')
df1 = df.copy(deep=True)
df1

df['local authority: district / unitary (prior to April 2015)'] == 'Rhondda Cynon Taf'

# Drop the 'All categories: Highest level of qualification' column
df1.drop('All categories: Highest level of qualification', axis=1, inplace=True)

"""reorganize 2011 dataset to have same rows and columns as 2021 dataset for merge"""

# Create an empty DataFrame for the new structure
reorganized_df = pd.DataFrame(columns=['local_authority', 'highest_qualification_level', 'highest_qualification', 'Observation'])

# Iterate through each row of the original dataset
for _, row in df1.iterrows():
    local_authority = row['local authority: district / unitary (prior to April 2015)']

    # Iterate through each qualification level column
    for level in range(1, 8):
        column_name = df1.columns[level]
        observation = row[column_name]

        # Create a new DataFrame with a single row
        new_row = pd.DataFrame({
            'local_authority': [local_authority],
            'highest_qualification_level': [level - 1],
            'highest_qualification': [column_name],
            'Observation': [observation]
        })

        # Concatenate the new row to the existing DataFrame
        reorganized_df = pd.concat([reorganized_df, new_row], ignore_index=True)

reorganized_df['local_authority'] == 'West Northamptonshire'

reorganized_df.local_authority.nunique()

reorganized_df

max_count = reorganized_df['Observation'].max()
rows_with_max_count = reorganized_df[reorganized_df['Observation'] == max_count]
print(rows_with_max_count)

data

false_indices = reorganized_df.loc[~reorganized_df['local_authority'].isin(reorganized_df['local_authority']), 'local_authority']
false_indices.unique()

"""edited the names of 'Bournemouth, Christchurch and Poole' to 'Bournemouth in (2021),
edited 'Herefordshire, County of' to 'Herefordshire' in 2011
edited 'Rhondda Cynon Taff' to 'Rhondda Cynon Taf' in 2011,
edited 'Kingston upon Hull, City of' to 'Kingston upon Hull' (2011),
2011: Tauton Deane, West Somerset = Somerset West and Taunton,
2011: Corby, East Northamptonshire, Kettering, Wellingborough = North Northamptonshire,
2011: Daventry, Northampton, South Northamptonshire = West Northamptonshire,
edited 'Bristol, City of' to 'Bristol' in 2011,
2011: 'Weymouth and Portland', 'West Dorset', 'North Dorset', 'Purbeck','East Dorset' = Dorset,
2011: Aylesbury Vale, Chiltern, South Bucks, Wycombe = Buckinghamshire (2011)
2011: Bournemouth, Christchurch, Poole = Bournemouth (2011)
2011: 'Forest Heath', 'St Edmundsbury' = West Suffolk
2011: 'Waveney','Suffolk Coastal' = East Suffolk
"""

matching_rows = reorganized_df[reorganized_df['local_authority'].str.contains('Northamptonshire', case=False)]
print(matching_rows)

sum_2011 = reorganized_df['Observation'].sum()
sum_2021 = data['Observation'].sum()

print('2011:', sum_2011, '2021: ', sum_2021)

reorganized_df['highest_qualification']

reorganized_df

copy_data = data.copy(deep=True)
copy_data = copy_data.drop('local_authorities_code',axis=1)
copy_data

"""check for any missing local authorities"""

local_authorities_only_in_2021 = set(data['local_authority']) - set(reorganized_df['local_authority'])

# Check local authorities in df2 that are not in df1
local_authorities_only_in_2011 = set(reorganized_df['local_authority']) - set(data['local_authority'])

local_authorities_only_in_2011

local_authorities_only_in_2021

"""merge the 2011 and 2021 datasets"""

# Merge the datasets based on 'local_authority', 'highest_qualification_level', and 'highest_qualification' columns
merged_df = pd.merge(copy_data, reorganized_df, on=['local_authority', 'highest_qualification_level', 'highest_qualification'])

# Rename the 'Observation' columns with suffixes
merged_df.rename(columns={'Observation_x': '2021_Observation', 'Observation_y': '2011_Observation'}, inplace=True)
merged_df

merged_df.local_authority.nunique()

merged_df[merged_df['local_authority'] == 'Hartlepool']

"""make sure the data types of the 'Observation' columns are int64"""

merged_df['2021_Observation'] = merged_df['2021_Observation'].astype('int64')

merged_df['2011_Observation'] = merged_df['2011_Observation'].astype('int64')

merged_df['2011_Observation'].dtype

merged_df.index

"""dividing the local authorities into regions"""

# Define the list of local authorities in the West Midlands
west_midlands = ['Birmingham','Bromsgrove','Cannock Chase', 'Coventry', 'Dudley','East Staffordshire', 'Herefordshire, County of',
                             'Lichfield','Malvern Hills','Newcastle-under-Lyme','North Warwickshire','Nuneaton and Bedworth','Redditch',
                             'Rugby','Sandwell','Shropshire', 'Solihull', 'South Staffordshire','Stafford','Staffordshire Moorlands',
                             'Stoke-on-Trent','Stratford-on-Avon','Tamworth','Telford and Wrekin', 'Walsall', 'Warwick', 'Wolverhampton',
                             'Worcester','Wychavon','Wyre Forest']

# Define the list of local authorities in the West Midlands
south_west = ['Bath and North East Somerset','Bournemouth','Bristol','Cheltenham','Cornwall','Cotswold','East Devon',
                          'Dorset','Exeter','Forest of Dean','Gloucester','Isles of Scilly','Mendip','Mid Devon','North Devon',
                          'North Somerset','Plymouth','Sedgemoor','Somerset West and Taunton','South Gloucestershire','South Hams',
                          'South Somerset','Stroud','Swindon','Teignbridge','Tewkesbury','Torbay','Torridge','West Devon','Wiltshire']

# Define the list of local authorities in the West Midlands
south_east = ['Adur','Arun','Ashford','Basingstoke and Deane','Brighton and Hove','Bracknell Forest','Buckinghamshire',
                          'Canterbury','Cherwell','Chichester','Crawley','Dartford','Dover','East Hampshire','Eastbourne','Eastleigh',
                          'Elmbridge','Epsom and Ewell','Fareham','Folkestone and Hythe','Gosport','Gravesham','Guildford',
                          'Hart','Hastings','Havant','Horsham','Isle of Wight','Lewes','Maidstone',
                          'Medway','Mid Sussex','Milton Keynes','Mole Valley','New Forest','Oxford','Portsmouth','Reading','Reigate and Banstead',
                          'Rother','Runnymede','Rushmoor','Sevenoaks','Slough','South Oxfordshire','Southampton','Spelthorne','Surrey Heath',
                          'Swale','Tandridge','Test Valley','Thanet','Tonbridge and Malling','Tunbridge Wells','Vale of White Horse',
                          'Waverley','Wealden','West Berkshire','West Oxfordshire','Winchester','Windsor and Maidenhead','Woking',
                          'Wokingham','Worthing']

# Define the list of local authorities in the West Midlands
yorkshire_and_humber = ['Barnsley','Bradford','Calderdale','Craven','Doncaster','East Riding of Yorkshire','Hambleton',
                                    'Harrogate','Kingston upon Hull','Kirklees','Leeds','North East Lincolnshire','North Lincolnshire',
                                    'Richmondshire','Rotherham','Ryedale','Scarborough','Selby','Sheffield',
                                    'Wakefield', 'York']

# Define the list of local authorities in the east Midlands
east_midlands = ['Amber Valley','Ashfield','Bassetlaw','Blaby','Bolsover','Boston','Broxtowe','Charnwood','Chesterfield',
                             'Derby','Derbyshire Dales','East Lindsey','Erewash','Gedling','Harborough','High Peak','Hinckley and Bosworth',
                             'Leicester','Lincoln','Mansfield','Melton','Newark and Sherwood','North East Derbyshire','North Kesteven',
                             'North West Leicestershire','North Northamptonshire','Nottingham','Oadby and Wigston','Rushcliffe',
                             'South Derbyshire','South Holland','South Kesteven','Rutland','West Northamptonshire','West Lindsey']

# Define the list of local authorities in the north west
north_west = ['Allerdale','Barrow-in-Furness','Blackburn with Darwen','Blackpool','Bolton','Bury','Carlisle','Wyre',
                          'Cheshire East','Cheshire West and Chester','Chorley','Copeland','Eden','Fylde',
                          'Halton','Hyndburn','Knowsley','Lancaster','Liverpool','Manchester','Oldham','Pendle','Preston','Ribble Valley',
                          'Rochdale','Rossendale','Burnley','Salford','Sefton','South Lakeland','South Ribble','St. Helens',
                          'Stockport','Tameside','Trafford','Warrington','West Lancashire','Wigan','Wirral']

# Define the list of local authorities in the greater london
greater_london = ['City of London','Westminster','Kensington and Chelsea','Hammersmith and Fulham','Wandsworth',
                                'Lambeth','Southwark','Tower Hamlets','Hackney','Islington','Camden','Brent','Ealing','Hounslow',
                              'Richmond upon Thames','Kingston upon Thames','Merton','Sutton','Croydon','Bromley','Lewisham','Greenwich','Bexley','Havering',
                              'Barking and Dagenham','Redbridge','Newham','Waltham Forest','Haringey','Enfield','Barnet','Harrow',
                              'Hillingdon']

# Define the list of local authorities in the north east
north_east = ['Darlington','County Durham','Gateshead','Hartlepool','Middlesbrough','Newcastle upon Tyne','Northumberland',
                          'North Tyneside','Redcar and Cleveland','South Tyneside','Stockton-on-Tees','Sunderland']

# Define the list of local authorities in the East of England
east_of_england = ['Babergh','Basildon','Braintree','Breckland','Brentwood','Broadland','Broxbourne','Cambridge',
                               'Castle Point','Luton','Central Bedfordshire','Bedford','Chelmsford','Colchester','Dacorum','East Cambridgeshire',
                               'East Hertfordshire','East Suffolk','Epping Forest','Fenland','Great Yarmouth','Harlow','Huntingdonshire',
                               'Hertsmere','Ipswich',"King's Lynn and West Norfolk",'Maldon','Mid Suffolk',
                               'North Hertfordshire','North Norfolk','Norwich','Peterborough','Rochford','St Albans','Southend-on-Sea','South Cambridgeshire',
                               'South Norfolk','Stevenage','Suffolk Coastal','Tendring','Three Rivers','Thurrock','Uttlesford',
                               'Watford','Welwyn Hatfield','West Suffolk']
south_wales_east = ['Vale of Glamorgan','Rhondda Cyon Taf','Merthyr Tydfil','Caerphilly','Cardiff','Newport','Blaenau Gwent',
                    'Torfan','Monmouthshire','Bridgend']
mid_and_west_wales = ['Powys','Ceredigion']
south_wales_west = ['Carmarthenshire','Neath Port Talbot','Pembrokeshire','Swansea']
north_wales = ['Conwy','Denbighshire','Flintshire','Gwynedd','Wrexham','Isle of Anglesey']

# Define the list of local authorities in the Wales
south_wales = ['Vale of Glamorgan','Rhondda Cynon Taf','Merthyr Tydfil','Caerphilly','Cardiff','Newport','Blaenau Gwent',
                'Torfaen','Monmouthshire','Bridgend']
mid_wales = ['Powys','Ceredigion']
west_wales = ['Carmarthenshire','Neath Port Talbot','Pembrokeshire','Swansea']
north_wales = ['Conwy','Denbighshire','Flintshire','Gwynedd','Wrexham','Isle of Anglesey']

# Create a list of conditions and corresponding values for sub-regions
conditions = [
    merged_df['local_authority'].isin(east_of_england),
    merged_df['local_authority'].isin(north_east),
    merged_df['local_authority'].isin(east_midlands),
    merged_df['local_authority'].isin(greater_london),
    merged_df['local_authority'].isin(north_west),
    merged_df['local_authority'].isin(yorkshire_and_humber),
    merged_df['local_authority'].isin(south_east),
    merged_df['local_authority'].isin(south_west),
    merged_df['local_authority'].isin(west_midlands),
    merged_df['local_authority'].isin(south_wales),
    merged_df['local_authority'].isin(mid_wales),
    merged_df['local_authority'].isin(west_wales),
    merged_df['local_authority'].isin(north_wales)
    # Add more conditions for other sub-regions if needed
]
values = ['East of England','North East','East Midlands','Greater London','North West',
          'Yorkshire and the Humber','South East', 'South West','West Midlands',
         'South Wales','Mid Wales','West Wales','North Wales']  # Corresponding sub-region names

# Assign the sub-region values to the 'sub_region' column based on the conditions
merged_df['sub_region'] = np.select(conditions, values, default=None)

"""check for local authorities that do not have sub regions"""

missing_subregion = merged_df[pd.isna(merged_df['sub_region'])]
missing_subregion['local_authority'].unique()

merged_df

"""Dash app"""

import webbrowser
from dash.dependencies import Input, Output
import dash_bootstrap_components as dbc
from dash import html
from urllib.request import urlopen

#json file for choropleth map
with urlopen('https://raw.githubusercontent.com/nenlep/python-app/main/Local_Authority_Districts_(December_2021)_GB_BFC.json') as response:
    Local_auth = json.load(response)

# Create the Dash app
external_stylesheets = ['https://github.com/nenlep/python-app/blob/main/assets/01_first.css',dbc.themes.FLATLY]
app = dash.Dash(__name__, external_stylesheets = external_stylesheets)
server = app.server

# Define the layout of the app
app.layout = dbc.Container([
    dbc.Row([
        dbc.Col(html.H4("Comparing levels of qualification in England and wales (2011 v 2021)",className='text-center'),width=12)
    ]),
    dbc.Row([
    # Choropleth map
        html.Div(className='choropleth',children=[
                html.Label('Select qualification level:'),
                dcc.Dropdown(
                id='qual_level',
                options=[
                    {'label': level, 'value': level} for level in merged_df['highest_qualification_level'].unique()
                ],
                value=merged_df['highest_qualification_level'].unique()[0],  # Set initial value to the first qualification level
                clearable=False
                ),
                dbc.Col([
                    html.Label('Select year:'),
                    dbc.RadioItems(
                    className = 'flex',
                    id='observation_year',
                    options=[
                        {'label': '2011', 'value': '2011_Observation'},
                        {'label': '2021', 'value': '2021_Observation'}
                    ],
                    value='2011_Observation',
                ),
                dcc.Graph(id='choropleth-map', className="choropleth-map"),
            ]),
        ]),
    ]),

    #bar charts
    dbc.Row([
        # Bar chart for local authorities
        html.Div(className='local_auth',children=[
            # dbc.Row(,
                dbc.Col([
                    html.H6("Comparing levels of qualification for each local authority",className='text-center'),
                    html.Label('Select Local Authority:'),
                    dcc.Dropdown(
                        id='local_authority',
                        className = 'mb-2',
                        options=[{'label': authority, 'value': authority} for authority in merged_df['local_authority'].unique()],
                        value=merged_df['local_authority'].unique()[0],  # Set initial value to the first local authority
                        clearable=False),
                    dcc.Graph(id='local-authority-bar-chart')],width={"size": 6},className = 'mr-4',
                ),
            # Bar chart for sub-regions
                dbc.Col([
                    html.H6("Comparing levels of qualification for each sub-region",className='text-center'),
                    html.Label('Select sub-region:'),
                    dcc.Dropdown(
                        className = 'mb-2',
                        id='sub_region',
                        options=[{'label': region, 'value': region} for region in merged_df['sub_region'].unique()],
                        value=merged_df['sub_region'].unique()[0],  # Set initial value to the first local authority
                        clearable=False),
                    dcc.Graph(id='sub-region-bar-chart')],width=6
                ),
            ])
        ],className='mt-4 mb-4 flex-row'),

    #pie chart
      dbc.Row([
        html.Label('Qualification Level Distribution'),
        # Bar chart for local authorities
        html.Div(className='local_auth',children=[
            # dbc.Row(,

                dbc.Col([
                    dcc.Graph(id='pie-chart-2011'),
                    # className = 'mr-4',
                ],width=6),
            # Bar chart for sub-regions
                dbc.Col([
                    dcc.Graph(id='pie-chart-2021')
                ],width=6),
            ])
        ],className='mt-4 mb-4 flex-row'),

#========================================================
    # # scatterplot
    # dbc.Row([

    #     html.Div(children=[
    #         dbc.Col([
    #              html.Label('Select qualification level:'),
    #             dcc.Dropdown(
    #                 id='qualification-level-dropdown',
    #                 options=[{'label': ql, 'value': ql} for ql in merged_df['highest_qualification_level'].unique()],
    #                 value=None
    #             ),
    #             html.Label('Select sub-region:'),
    #             dcc.Dropdown(
    #                 id='sub-region-dropdown',
    #                 options=[{'label': sr, 'value': sr} for sr in merged_df['sub_region'].unique()],
    #                 multi=True,
    #                 value=[]
    #             ),
    #             dcc.Graph(id='scatter-plot')
    #         ])
    #     ])
    # ])
#=============================================================
])


# Callback to update choropleth map
@app.callback(
    Output('choropleth-map', 'figure'),
    [Input('qual_level', 'value'),
     Input('observation_year', 'value')]
)
def update_choropleth(qualification_level, observation_year):
    # Select the appropriate column based on the chosen observation year
    observation_column = observation_year
    if observation_year == '2011_Observation':
        year = '2011'
    else:
        year = '2021'

    # Filter the dataframe based on selected qualification level
    filtered_df = merged_df[merged_df['highest_qualification_level'] == qualification_level]

    # Create the choropleth map
    fig = px.choropleth_mapbox(
        filtered_df,
        geojson=Local_auth,
        locations=filtered_df['local_authority'],
        featureidkey='properties.LAD21NM',
        color=observation_column,
        center={"lat": 53.09621, "lon": -4.0286298},
        color_continuous_scale='viridis',
        mapbox_style="carto-positron",
        title=f'Choropleth map comparing Level {qualification_level} qualifications for all local authorities in England and Wales for the year {year}',
        zoom=4.3,
        height = 500,
        hover_name='local_authority',
        labels={'2011_Observation': 'Qualification Count in 2011',
                '2021_Observation': 'Qualification Count in 2021',
                }
    )
    return fig


# Callback to update bar chart for local authorities
@app.callback(
    Output('local-authority-bar-chart', 'figure'),
    [Input('local_authority', 'value')]
)
def update_local_authority_bar_chart(selected_local_authority):
    # Filter the dataframe based on the selected local authority
    filtered_df = merged_df[merged_df['local_authority'] == selected_local_authority]

    # Create the comparative bar chart
    fig = px.bar(
        data_frame=filtered_df,
        x='highest_qualification_level',
        y=['2011_Observation', '2021_Observation'],
        title=f'Highest Qualification Levels in {selected_local_authority} (2011 v 2021)',
        labels={'x': 'Qualification Level', 'y': 'Observation'},
        barmode='group'
    )

    fig.update_layout(
    legend_title_text='Observation Year',
    hovermode='x unified',
    xaxis_title='Qualification Level',
    yaxis_title='Count',
    hoverlabel=dict(
            # bgcolor="black",
            font_size=12,
            font_family="Rockwell"
        )
    )

    return fig

# callback for pie charts
@app.callback(
    Output('pie-chart-2011', 'figure'),
    [Input('pie-chart-2011', 'id')]
)
def update_pie_chart_2011(_):
    #get total qualification counts for each level
    qualification_counts_2011 = merged_df['2011_Observation'].groupby(merged_df['highest_qualification_level']).sum()

    #total count for all levels
    total_counts_2011 = qualification_counts_2011.sum()

    #percentages
    percentages_2011 = (qualification_counts_2011 / total_counts_2011) * 100

    #sort levels in ascending order
    sorted_levels_2011 = sorted(merged_df['highest_qualification_level'].unique())

    pie_chart_2011 = go.Figure(data=[go.Pie(labels=percentages_2011.index,
                                            values=qualification_counts_2011.values,
                                            hovertemplate='<extra></extra>Level: %{label} <br>Count: %{value} ',
                                            textinfo='label+percent')])

    pie_chart_2011.update_layout(title_text='2011 Highest Qualification Level in percentages')
    pie_chart_2011.update_traces(sort=False, legendgroup='group')

    return pie_chart_2011


@app.callback(
    Output('pie-chart-2021', 'figure'),
    [Input('pie-chart-2021', 'id')]
)
def update_pie_chart_2021(_):
    #get total qualification counts for each level
    qualification_counts_2021 = merged_df['2021_Observation'].groupby(merged_df['highest_qualification_level']).sum()

    #total count for all levels
    total_counts_2021 = qualification_counts_2021.sum()

    #percentages
    percentages_2021 = (qualification_counts_2021 / total_counts_2021) * 100

    #sort levels in ascending order
    sorted_levels_2021 = sorted(merged_df['highest_qualification_level'].unique())

    pie_chart_2021 = go.Figure(data=[go.Pie(labels=percentages_2021.index,
                                            values=qualification_counts_2021.values,
                                            hovertemplate='<extra></extra>Level: %{label} <br>Count: %{value} ',
                                            textinfo='label+percent')])

    pie_chart_2021.update_layout(title_text='2021 Highest Qualification Level in percentages')
    pie_chart_2021.update_traces(sort=False, legendgroup='group')

    return pie_chart_2021


# Callback to update bar chart for sub-regions
@app.callback(
    Output('sub-region-bar-chart', 'figure'),
    [Input('sub_region', 'value')]
)
def update_sub_region_bar_chart(selected_sub_region):
    # Filter the DataFrame based on the selected sub-region
    filtered_df = merged_df[merged_df['sub_region'] == selected_sub_region]

    # Group the filtered DataFrame by 'Highest_Qualification_Level' and calculate the count for 2011 and 2021
    grouped_df = filtered_df.groupby('highest_qualification_level')[['2011_Observation', '2021_Observation']].sum().reset_index()

    # Create the grouped bar chart using Plotly Express
    fig = px.bar(
        grouped_df,
        x='highest_qualification_level',
        y=['2011_Observation', '2021_Observation'],
        barmode='group',
        template='plotly_dark',
    )

    # Modify the hovertemplate to include the desired labels
    fig.update_traces(hovertemplate='<br>Count %{y}')

    # Customize other layout properties as needed
    fig.update_layout(
        title=f'Highest Qualification Levels in {selected_sub_region} (2011 v 2021)',
        xaxis_title='Qualification Level',
        yaxis_title='Count',
        legend_title_text='Observation Year',
        hovermode='x unified',
        hoverlabel=dict(
            # bgcolor="black",
            font_size=12,
            font_family="Rockwell"
        )
    )

    return fig

# ====================================================================
# #callback for scatterplot
# @app.callback(
#     Output('scatter-plot', 'figure'),
#     [Input('qualification-level-dropdown', 'value'),
#      Input('sub-region-dropdown', 'value')]
# )
# def update_scatter_plot(qualification_level, sub_regions):
#     filtered_data = merged_df[
#         (merged_df['highest_qualification_level'] == qualification_level) &
#         (merged_df['sub_region'].isin(sub_regions))
#     ]

#     scatter_plot = px.scatter(filtered_data, x='2011_Observation', y='2021_Observation',
#                               title=f'Comparing Observations for qualification level {qualification_level} in {sub_regions} (2011 v 2021)',
#                               color='sub_region', hover_name='local_authority',
#                               labels={'2011_Observation': 'Qualification Count in 2011',
#                                       '2021_Observation': 'Qualification Count in 2021',
#                                       'sub_region': 'Sub-Region'}
#                              )

#     return scatter_plot
#========================================================================

# Run the app
if __name__ == '__main__':
    app.run_server(debug=True)
# webbrowser.open_new_tab('http://localhost:8050/')  # Replace with the appropriate URL

